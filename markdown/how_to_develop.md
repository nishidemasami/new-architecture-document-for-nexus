# AIによるプログラム生成（またはフリーランス・オフショア・未熟なプログラマーなど）により開発されたプログラムの品質を担保する手法

今やAIを駆使してプログラミングをすることは当たり前の時代です。  
かつて、大人数でやっていたような大規模システムもAIの補助を受けて1人で作れるようになりました。  
プログラミングAIには以下のようなサービスがあります。

- Amazon CodeWhisperer <https://aws.amazon.com/jp/codewhisperer/>
- GitHub Copilot <https://docs.github.com/ja/copilot>

AIによるプログラム生成とフリーランスやオフショア、未熟なプログラマーにプログラム開発を発注・委託したりすることには、ある共通点があります。それは ***そのプログラムが正しいかどうか、わからないこと*** です。

本章では、プログラムの品質担保手法について説明します。

## プログラムが「正しい」ということとは

たとえばあなたがFizzBuzzプログラムをAIに要求としたとしましょう。  

> ❗FizzBuzzプログラムとは、与えた数字が3の倍数の場合は「Fizz」、5の倍数の場合は「Buzz」、3の倍数かつ5の倍数の場合は「FizzBuzz」、どれでもない場合はその数字を出力するプログラムのことです。

もしあなたが「与えた数字が3の倍数の場合は「Fizz」、5の倍数の場合は「Buzz」、3の倍数かつ5の倍数の場合は「FizzBuzz」、どれでもない場合はその数字を出力するプログラムを書いてください」とだけAIに言ったら、どんなプログラムが出来上がるでしょうか？出来上がったプログラムを見て初めて発覚する仕様の考慮漏れを発見するでしょう。例えば、与えられる数字の最大桁数がわからなければ32bit整数を使えばいいか64bit整数を使えばいいかも定義できません。バグがあるかもしれません。15と入力すると「FizzBuzzFizzBuzz」と出力されてしまうかもしれません。数字が負の数や少数だったり、2147483647を超えるとエラーが発生してシステムが落ちるかもしれません。大量の文字列を入力するとバッファオーバーフローが発生しPCが乗っ取られるかもしれません。  

一体なにが悪かったのでしょうか？AI？あなたの指示？仕様？？  
ここでは犯人探しはしません。「正しい」ということを確認できる手法を解説するに留めます。  
信頼できる熟練の技術者が大勢いて全員が無償で作業してくれる場合には品質担保手法について考える必要は無いかもしれません。しかし、大抵の場合はプログラムの品質をなんらかの形で担保する必要があります。  

## プログラムの品質を担保する手法

プログラムの品質を担保するには、以下のような手法が存在します。

- 形式手法
- 自動テスト
- 静的プログラム解析
- 型

### 形式手法

形式手法は、プログラムが正しいことを数学的に証明する手法です。
古くは自動改札機の運賃計算プログラム[^1]、最近ではAmazon S3[^2]などで、プログラムの正しさの検証に使用されています。IPAは国外の12件の事例について読み応えのある資料をPDFで公開[^3]しています。

形式手法は非常に強力ですが、仕様を厳密に定義できるものにしか適用できません。しかし先述の自動改札機の運賃計算プログラム事例では運賃計算の仕様の不備が判明するなど、裏を返せば仕様を厳密に定義”させられる”というメリットがあるとも言えます。

[^1]: [自動改札機の運賃計算プログラムはいかにデバッグされているのか？ 10の40乗という運賃パターンのテスト方法を開発者が解説（後編） － Publickey](https://www.publickey1.jp/blog/12/_1040_2.html)
[^2]: [Using Lightweight Formal Methods to Validate a Key-Value Storage Node in Amazon S3](https://assets.amazon.science/07/6c/81bfc2c243249a8b8b65cc2135e4/using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3.pdf)
[^3]: <https://www.ipa.go.jp/archive/files/000004547.pdf>,<https://www.ipa.go.jp/archive/files/000004548.pdf>

### 自動テスト

形式手法を適用できない場合、自動テストによりプログラムの品質を担保します。  
自動テストでは、人間の手では到底できないような膨大な量のテストケースでも高速にテストすることができます。  
また、後述のCI/CDによって、なんらかのプログラムの変更が他のプログラムに影響してバグが発生した場合にも自動で検知されます。

自動テストは現在のシステム開発においては、よほど特殊な事情（バグがたくさんあった方が儲かると経営者が判断した、バグにより社会を混乱させたいという願望がある、など）がない限りは必ず使用されます。  
自動テストのためも完備されていて、現代的な全てのプログラム言語には自動テストのためのツールが存在します。  
しかし、これらも正しく使わなければなんの意味もありません。自動テストを利用する勘どころは以下の通りです。

- 常に更新し、常にテストする  
  せっかく自動テストが使える環境にあっても、仕様の更新に合わせてテストも更新されなければなんの意味もありません。また、常にテストされなければいつバグが発生したのかもわかりません。
- 自動テストは書かれたことしかテストしない  
  仕様を全て自動テストで書くことができれば、（仕様が完璧である限り）プログラムにはバグが無いことを確認することができます。
- 自動テスト可能なプログラムを書く  
  数万行に膨れ上がった、いわゆる「神クラス」を十分にテストすることは困難です。テスト可能なようにプログラムの構造を疎結合に保つことは自動テストの観点からも重要です。

一般的なフロントエンドのテスト指針であるThe Testing Trophy[^4]を参考に、自動テストを以下の種類に分けその性質とテストの粒度を説明します。

- End to End
- Integration
- Unit
- Static

#### End to End

エンドツーエンドのテストです。いわゆる全体テストとかシステムテスト、総合テストと呼ばれるものです。
たとえばWebシステムの自動テストであれば、Dockerで自動でWebサーバとDBサーバを起動し、SeleniumやPuppeteer、Playwrightなどを使って自動でブラウザを叩くという流れをテストします。
複雑で規模が大きいテストなため当然ながらテストの記述量も多くなり書くのにも時間もかかり、かつ、テストの粒度も荒くなります。たとえば「ひらがなしか入力できない」という項目に対して全漢字をチェックするようなテストはこの段階ではしません。この段階のテストのケース数はコストの観点からそこまで多くはできません。

#### Integration

いわゆる結合テストです。
たとえばWebシステムの自動テストであれば、Webサーバでの動作が正しくDBに反映されるかから、なんらかの機能が正しくなんらかの共通ロジックを呼ぶことができているかまで多くのテストをここでします。The Testing Trophy[^4]ではこの段階のテストが最も量が多いです。

#### Unit

いわゆる単体テストです。
たとえばWebシステムの自動テストであれば、Webサーバでの動作が正しくDBに反映されるかから、なんらかの機能が正しくなんらかの共通ロジックを呼ぶことができているかまで多くのテストをここでします。The Testing Trophy[^4]ではこの段階のテストが最も量が多いです。

#### Static

いわゆる静的プログラム解析です。

プログラミング言語にRustを採用する場合、普通にプログラミングしてビルドが通ったことを確認するだけで静的テストを満たします。

[^4]: [The Testing Trophy and Testing Classifications](https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications)

### 静的プログラム解析

### 型

型はプログラムに標準で備わっている軽量の形式手法であると言えます。
以下のプログラミング言語を使用すれば、自動的に型の恩恵を預かることができます。

- Rust
- TypeScript
- Go
- Java(Kotlin)
- Swift

以下のプログラミング言語

型があるプログラム言語を利用することは以下のメリットがあります。

- 発注したプログラムの検収作業が正確にできるようになる。
- 開発効率が向上する。
- モジュール同士が疎結合になり、開発がスケールする。

***
ここから書きかけです
***

### 手動テスト

## IDL

IDL型定義

## GraphQL

graphqlsファイル

## Protocol Buffers

.protoファイル

